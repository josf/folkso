<?php

class folksoUserCreds {
  public $userid;
  public $digest;
  public $method;
  public $realm;

  /**
   * Once parsed by http_digest_parse(), the digest data goes into
   * this assoc array.
   */
  public $digest_data = array();

  /**
   * $method should be $_SERVER['REQUEST_METHOD']
   */
  function __construct ($digest, $method, $realm) {
    $this->digest = $digest;
    $this->method = $method;
    $this->realm = $realm;
  }

  /**
   * The checking is not done in the __construct because we may not
   * need to check sometimes (for GETs, essentially) and since that
   * involves a database connection, it isn't worth it.
   */
  function check_digest () {   // completely bogus for now...
    if ($this->digest == 'xyz') {
      $this->userid = 99999;
    }
    else {
      return false;
    }
  }

  function get_username () {
    return 'folksy';
    //    return $this->username;
  }

  function tag_create_access () {
    return true;
  }

  function admin_access () {
    return true;
  }
  function userid () {
    return $this->userid;
  }


  /**
   * Partly inspired by the Auth HTTP PEAR library. Returns an assoc
   * array of the key/value pairs from a digest authorization response
   * header.
   *
   */
  function http_digest_parse($txt = '') {
    if (strlen($txt) == 0) {
      $txt = $this->digest;
    }

    $raw = explode(',', $txt);
    $auth = array();
    foreach ($raw as $rr) {
      $key = '';
      $val = '';

      $rr = trim($rr);
      if(strpos($rr,'=') !== false) {
        $lhs = substr($rr,0,strpos($rr,'='));
        $rhs = substr($rr,strpos($rr,'=')+1);
        $lhs = trim($lhs);
        $rhs = trim($rhs);

        if ((substr($rhs, 0, 1) == substr($rhs, -1, 1)) &&
            ((substr($rhs, 0, 1) == '"') ||
             (substr($rhs, 0, 1) == "'"))) {
          $val = substr($rhs, 1, (strlen($rhs) - 2));
        }
        else {
          $val = $rhs;
        }

        // avoiding the 'Digest firstparam="' part
        if (strstr($lhs, ' ') == false) {
          $key = $lhs;
        }
        else {
          $key = substr($lhs, (strpos($lhs, ' ') + 1));
        }
        $auth[$key] = $val;
      }
    }
    if (isset($auth['username'])){
      $this->username = $auth['username'];
    }
    $this->digest_data = $auth;
    return $auth;
  }
   
  /**
   * Verify that the digest contains all the necessary fields.
   *
   */
  function validateAuth () {
    $required = array('username', 'nonce', 'nc', 'cnonce', 'qop', 'response', 'opaque');
    foreach ($required as $ff) {
      if (!isset($this->digest_data[$ff])) {
        return false;
      }
    }
    return true;
  }


/**
 * Is this a valid username?
 */
function checkUsername($user) {
  if ($user == 'folksy') {
    return true;
  }
  else {
    return false;
  }
}

function getUserPasswd ($user) {
  if ($user == 'folksy') {
    return "folksong";
  }
}

/** 
 * $auth is an array generated by http_parse_digest()
 *
 */

function generateCorrectDigestResponse ($auth = '') {
  if (!is_array($auth)) {
    $auth = $this->digest_data;
  }
  /*
  var_dump($auth);

  $a1 = md5($auth['username'] . ':' . $this->realm . ':' . $this->getUserPasswd($auth['username']));
  $a2 = md5($this->method .':'.$data['uri']);
  $valid = md5(implode(array( $a1, $auth['nonce'], $auth['nc'], $auth['cnonce'], $auth['qop'], $a2)), ':');
  return $valid; */

 $ret =  $this->buildDigestResponse( $auth, 
                       $this->buildDigestA1($auth, $this->realm, 'folksy'),
                       $this->buildDigestA2($auth, $this->method));
 return $ret;
}

function buildDigestResponse ($auth, $a1unhashed, $a2unhashed) {
  $r_unhashed = 
    md5($a1unhashed) . ':' .
    $auth['nonce'] . ':' .
    $auth['nc'] . ':' .
    $auth['cnonce'] . ':' .
    $auth['qop'] . ':' .
    md5($a2unhashed);
  return $r_unhashed;
}
 
function buildDigestA1 ($auth, $realm, $passwd) {
  $a1 =  $auth['username'] . ':' . $realm . ':' . $passwd;
  return $a1;
}   
    
function buildDigestA2 ($auth, $method) {
  $a2unhashed = $method . ':' . $auth['uri'];
  return $a2unhashed;
}

function displayDigestData () {
  foreach ($this->digest_data as $key => $val) {
    print "<p>$key ---- $val</p>";
  }
  print "<p>passwd ----" . $this->getUserPasswd('folksy') . "</p>";
}


  } //end class



?>